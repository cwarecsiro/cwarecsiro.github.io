<!DOCTYPE html>
<html>

<head>
    <title>VectorFieldAnim / ScalarField</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	
    <link rel="stylesheet" href="//unpkg.com/leaflet@1.2.0/dist/leaflet.css" />
    <link rel="stylesheet" href="examples.css" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,400" rel="stylesheet">
	
	<style>
	
body { margin:0; padding:0; }
#map { position:absolute; top:0; bottom:0; width:100%; }

</style>
</head>

<body>

    <h1 class="title mapTitle">Recent ecological change in Australia</h1>

	
	<div id="map"></div>
	
	<div id="floating-panel">
        <ul>

            <li id="colorBrewerPanel">
                <label>Palettes</label>
                <!-- some color scales... (for a full list see: https://github.com/gka/chroma.js/wiki/Predefined-Colors) -->
                <select id="colorBrewer">
                    <option>OrRd</option>
                    <option>PuBu</option>
                    <option>BuPu</option>
                    <option>Oranges</option>
                    <option>RdPu</option>
                    <option>YlGnBu</option>
                    <option>GnBu</option>
                    <option>PuRd</option>
                    <option>PuBuGn</option>
                    <option>Spectral</option>
                    <option>RdYlGn</option>
                    <option>PiYG</option>
                    <option>Paired</option>
                </select>
            </li>

        </ul>
    </div>
	
	
	
    <!-- CDN -->
    <script src="//d3js.org/d3.v4.min.js"></script>
    <script src="//npmcdn.com/leaflet@1.2.0/dist/leaflet.js"></script>
	<script src="//npmcdn.com/geotiff@0.3.6/dist/geotiff.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/1.3.0/chroma.min.js"></script>

    <!-- Plugin -->
    <script src="dist/leaflet.canvaslayer.field.js"></script>

	<link rel="stylesheet" href="dist/L.Control.Range.css" />
	<script src="dist/L.Control.Range-min.js"></script>
	
    <script>
        let map = L.map("map");

        // Basemap
        let url = 'https://cartodb-basemaps-{s}.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}.png';
        L.tileLayer(url, {
            attribution: 'OSM & Carto',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);
		
		
		var slider = L.control.range({
			position: 'bottomleft',
			min: 0,
			max: 4,
			value: 0,
			step: 1,
			orient: 'horizontal',
			iconClass: 'leaflet-range-icon',
			icon: true
		});


		var years = ['1947', '1947', '1947', '1947'];

		// add hcas
				d3.request("data/hcas2.tiff").responseType('arraybuffer').get(
					function (error, tiffData) {
					
		
		d3.text('data/PA5_' + '1997' + '_' + '2017' + '_CPRISTINE_S30kmFill_U.asc', function (up) {
		//d3.text('data/Atlantic_U.asc', function (u) {
		
		d3.text('data/PA5_' + '1997' + '_' + '2017' + '_CHCAS2_S30kmFill_U.asc', function (uh) {
		
            d3.text('data/PA5_' + '1997' + '_' + '2017' + '_CPRISTINE_S30kmFill_V.asc', function (vp) {
			
			d3.text('data/PA5_' + '1997' + '_' + '2017' + '_CHCAS2_S30kmFill_V.asc', function (vh) {
			
						
			// Geopotential height (BAND 0)
					let geo = L.ScalarField.fromGeoTIFF(tiffData.response, bandIndex = 0);

					let HCAS = L.canvasLayer.scalarField(geo, {
						color: chroma.scale('YlGn').domain(geo.range),
						opacity: 0.25
						}).addTo(map);
							
						
						
			//d3.text('data/Atlantic_V.asc', function (v) {
                //const toMetersPerSecond = 0.001;
				const toMetersPerSecond = 10;
                //const vf = L.VectorField.fromGeoTIFFs(u, v);
				const vfp = L.VectorField.fromASCIIGrids(up, vp, toMetersPerSecond);
				//const vfp = L.VectorField.fromASCIIGrids(up, vp);
				
				const vfh = L.VectorField.fromASCIIGrids(uh, vh, toMetersPerSecond);
				//const vfh = L.VectorField.fromASCIIGrids(uh, vh);
                           
                // a) First derived field: Magnitude (m/s)
                const sp = vfp.getScalarField('magnitude'); // << derived ScalarField
                /*  custom scale, based on 'earth.nullschool.net'
                    (example:  https://earth.nullschool.net/#current/ocean/surface/currents/overlay=currents/equirectangular=-11.95,29.62,1112)
                */
				
				const sh = vfh.getScalarField('magnitude'); // << derived ScalarField
                /*  custom scale, based on 'earth.nullschool.net'
                    (example:  https://earth.nullschool.net/#current/ocean/surface/currents/overlay=currents/equirectangular=-11.95,29.62,1112)
                */
				
				var range_p = vfp.range;
				var range_h = vfh.range;
                var scale_p = chroma.scale('OrRd').domain(range_p);
				var scale_h = chroma.scale('OrRd').domain(range_h);
 				
                const magnitude_p = L.canvasLayer.scalarField(sp, {
                    //color: chroma.scale(
                     //   ['#1F263A', '#414AA9', '#44758C', '#399B58', 'DCD296', 'F2E899', 'A53E3C', '9C3333'], [.1, .2, .3, .4, .7, .9, 1.5, 2]
                    //),
					color: scale_p,
                    opacity: 0.65
                });
				
				const magnitude_h = L.canvasLayer.scalarField(sh, {
                    //color: chroma.scale(
                     //   ['#1F263A', '#414AA9', '#44758C', '#399B58', 'DCD296', 'F2E899', 'A53E3C', '9C3333'], [.1, .2, .3, .4, .7, .9, 1.5, 2]
                    //),
					color: scale_h,
                    opacity: 0.65
                });

                // b) Second derived field: DirectionFrom (º): (0 to 360º) | N is 0º and E is 90º
                const direction_p = L.canvasLayer.scalarField(
                    vfp.getScalarField('directionFrom'), {
                        type: 'vector',
                        color: 'white',
                        vectorSize: 25,
                        arrowDirection: 'from'
                    });
					
				const direction_h = L.canvasLayer.scalarField(
                    vfh.getScalarField('directionFrom'), {
                        type: 'vector',
                        color: 'white',
                        vectorSize: 25,
                        arrowDirection: 'from'
                    });

                const animation_p = L.canvasLayer.vectorFieldAnim(vfp, {
                    paths: 1000,
                    fade: 0.97,
                    maxAge: 100,
					width: 3,
                    //velocityScale: 1 / 40,
					velocityScale: 1 / 10000,
                    //color: 'rgba(255, 255, 255, 0.7)'
					color: scale_p
                }).addTo(map);
				
				const animation_h = L.canvasLayer.vectorFieldAnim(vfh, {
                    paths: 1000,
                    fade: 0.97,
                    maxAge: 100,
					width: 3,
                    //velocityScale: 1 / 40,
					velocityScale: 1 / 10000,
                    //color: 'rgba(255, 255, 255, 0.7)'
					color: scale_h 
                }).addTo(map);
				
							
				
                L.control.layers({}, {
                    "Vector animation pristing": animation_p,
					"Vector animation HCAS": animation_h,
                    "Derived magnitude pristing": magnitude_p,
					"Derived magnitude HCAS": magnitude_h,
                    "Derived direction pristing": direction_p,
					"Derived direction HCAS": direction_h,
					"HCAS 2 map": HCAS,
                }, {
                        position: 'bottomleft',
                        collapsed: false
                    }).addTo(map);


                map.fitBounds(HCAS.getBounds());
				//map.fitBounds(animation_h.getBounds());
				
				/*
				magnitude_p.on('click', function (e) {
                    if (e.value !== null) {
                        let v = e.value.toFixed(2);
                        let html = (`<span class="popupText">magnitude: ${v} </span>`);
                        let popup = L.popup().setLatLng(e.latlng).setContent(html).openOn(map);
                    }
                });

                direction_p.on('click', function (e) {
                    if (e.value !== null) {
                        let v = e.value.toFixed(0);
                        let html = (`<span class="popupText">direction: ${v}º</span>`);
                        let popup = L.popup().setLatLng(e.latlng).setContent(html).openOn(map);
                    }
                });
				*/
				//      colorBrewer scale
				let colorBrewer = document.getElementById('colorBrewer');
				colorBrewer.addEventListener('change', function () {
					var scale_p = chroma.scale(this.value).domain(s.range_p);
					magnitude.setColor(scale_p);
				});
				
				//      enable panels
				map.on('load', function (e) {
										let colorBrewerPanel = document.getElementById('colorBrewerPanel');
					colorBrewerPanel.style.display = (e.layer === magnitude_p) ? "block" : "none";
				});
				
			});
			});

			});
			});

	});	
		

	
		
		
    </script>
</body>

</html>